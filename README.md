## ПЗ-7 Славінський Костянтин ЦК-31
Код знаходиться у папці (src)

Структура (src):
1. Файл Product.java Клас, що описує сам товар.

2. Файл StoreItem.java
Допоміжний клас для зв'язування товару з його ціною в конкретному магазині.

3. Файл OnlineStore.java
Клас, що описує інтернет-магазин та зберігає список товарів у ньому.

4.Файл ProductSearchService.java
Головний клас (Main), що містить логіку завдань та точку входу в програму.

 
 ## Контрольні питання

**1. Для чого призначений Collections Framework?** Це уніфікована архітектура для представлення та маніпулювання групами об'єктів. Вона надає набір стандартних інтерфейсів (`List`, `Set`, `Map`) та їх реалізацій (наприклад, `ArrayList`, `LinkedList`) для зберігання, пошуку та обробки даних. Це дозволяє зменшити зусилля на програмування, підвищити продуктивність та забезпечити сумісність між різними API.

**2. В чому полягає різниця між масивами та колекціями?** * **Розмір:** Масиви мають фіксований розмір після створення; колекції можуть динамічно змінювати розмір (рости або зменшуватись).
* **Типи даних:** Масиви можуть зберігати як примітиви, так і об'єкти; колекції зберігають тільки об'єкти (для примітивів використовуються класи-обгортки, наприклад `Integer` замість `int`).
* **Функціонал:** Колекції мають широкий набір вбудованих методів для роботи з даними (сортування, пошук, перемішування), тоді як масиви мають обмежений функціонал.

**3. Які особливі властивості є у списків порівняно з іншими типами колекцій?** Списки (`List`) — це **впорядковані** колекції (ordered collections), які дозволяють зберігати **дублікати** елементів. Головна особливість — можливість точного контролю над позицією вставки елементів та доступ до них за цілочисельним індексом.

**4. Чим списки відрізняються від масивів?** Список (`List`) — це інтерфейс, який описує поведінку динамічної структури даних, тоді як масив — це базова конструкція мови з фіксованою ділянкою пам'яті. Списки дозволяють легко вставляти та видаляти елементи (автоматично зсуваючи інші), не вимагаючи від програміста ручного керування пам'яттю чи перестворення структури.

**5. Чим ArrayList відрізняється від LinkedList? Який з них у яких випадках краще використовувати?** * **ArrayList:** Базується на динамічному масиві. Забезпечує швидкий доступ до елементів за індексом (`get(i)` — O(1)), але повільний при вставці/видаленні елементів в середині списку (потребує зсуву масиву).  
    * *Коли використовувати:* Коли операції читання (get) переважають над записом/видаленням.
* **LinkedList:** Базується на двозв'язному списку. Забезпечує швидку вставку/видалення (`add`, `remove` — O(1)), але повільний доступ до елементів за індексом (потрібен перебір — O(n)).  
    * *Коли використовувати:* Коли часто відбуваються операції додавання або видалення елементів (особливо в середині списку).

**6. Що таке Iterator? В чому полягають переваги використання ітератора?** `Iterator` — це об'єкт, який дозволяє послідовно проходити через елементи колекції.  
**Переваги над циклом `for(int i=...)`:**
* Дозволяє **безпечно видаляти** елементи під час ітерації за допомогою методу `iterator.remove()`. У звичайному циклі (особливо `for-each`) спроба видалення викличе `ConcurrentModificationException`.
* Є універсальним для всіх колекцій, навіть тих, що не мають індексів (наприклад, `Set`).

**7. Що таке типізовані та нетипізовані колекції?** * **Типізовані (Generic):** Явно вказують тип даних, що зберігаються (наприклад, `ArrayList<String>`). Це забезпечує перевірку типів на етапі компіляції та позбавляє необхідності явного приведення типів (casting) при отриманні елементів.
* **Нетипізовані (Raw types):** Використовуються без вказання типу (наприклад, просто `ArrayList`). Вони зберігають об'єкти типу `Object`, що вимагає явного приведення типів і може призвести до помилок під час виконання (`ClassCastException`).

**8. Для чого потрібен інтерфейс RandomAccess?** Це інтерфейс-маркер (не містить методів), який вказує на те, що реалізація списку підтримує швидкий (зазвичай константний час) доступ до елементів за індексом. Наприклад, `ArrayList` реалізує цей інтерфейс, а `LinkedList` — ні. Алгоритми (наприклад, бінарний пошук `Collections.binarySearch`) перевіряють наявність цього інтерфейсу для вибору оптимальної стратегії обходу.

**9. Чим Collection відрізняється від Collections?** * **Collection:** Це кореневий **інтерфейс** ієрархії колекцій, від якого успадковуються `List`, `Set`, `Queue`. Він визначає базові методи (add, remove, size).
* **Collections:** Це утилітний **клас**, який складається виключно зі статичних методів для роботи з колекціями (сортування `sort`, пошук, перемішування `shuffle`, створення незмінних списків тощо).
